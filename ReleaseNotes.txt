1. Настоящая сеть с маршрутизацией. Для направления данных используется таблица маршрутизации. Реализован вариант конечной функции, независящий от роли устройства.
Есть проблемы с использованием буфера. Входящий пакет может полностью убить передаваемый пакет. Есть проблемы со стабильностью доставки данных. Хосту необходимо принудительно ждать несколько мс, для того чтобы девайс мог гарантированно закончить ретрансляцию. Использование регистра CD (Carrier detect) для исключения коллизий не дало результат.
2. Для устранения проблем с буфером применены 3 отдельных буфера. Для приема, передачи и составления маршрута в функции SetBridge(RFAddrTypeDef DevRFAddr) (чтобы не убить информацию в буфере на передачу). Проблема стабильности доставки данных решается выносом обработчика LAN_ProcessPacket(u8 *Data) и отключением прерываний на время обработки пакета. При этом считается, что обработка пакета заканчивается до окончания передачи данных ретрансляции.Во время обработки радиомодуль способен принять еще 3 пакета, но обработан устройством будет только один. DEVICE будет в курсе пропуска данных, HOST нет. Для исключения коллизий несколько раз проверяется бит CD.
3. Применен другой подход к повышению стабильности. Прерывания не отключаются никогда, но на время обработки пакета снимается сигнал CE, что запрещает работу приемника. Соответственно HOST не может достучаться до DEVICE, пока последний не окончит обработку пакета. И главное, что HOST знает об этом. Сигнал CE восстанавливается прямо в процедуре LAN_ProcessPacket(u8 *Data), что заставляет тратить время на всю фактическую передачу информации. Так же необходима задержка в HOST после передачи данных на то, чтобы DEVICE успел начать ретрансляцию данных. Иначе HOST может начать отправлять второй пакет еще до того как DEVICE отправит первый, чем заткнет его, что еще сильнее усугубит ситуацию. Эфир контролируется доработанной процедурой LAN_CheckRFActivity(void), которой теперь необходимо самой включать трансивер на прием для контроля наличия несущей в эфире. Т. о. в результате передача пакета по установленному мосту без ретрансляции составляет 3 ms, с ретрансляцией 5 ms.
4. Добавлена односторонняя связь с компьютером (компьютер -> устройство). Оказалось, что добавление данной связи в текущей стркуктуре сети не удобно. Необходимо роль хоста перенести на компьютер. Тогда все МК устройства будут иметь роль Device. 
5. компьютер сделан полноценным устройством в сети, все МК устройства имеют роль Device и не содержат кода Host. Однако прием пакета по UART и nRF осуществляется разными механизмами. Отсутствие подтверждения приема пакета по UART каналу накладывает ограничения на пропускную способность всей сети. Необходимо привести прием по UART в более унифицированный вид. Необходимо так же попробовать отказаться от отключения приемника nRF во время обработки пакета, заменив это на изменение адреса приемника на некий SILENCE_RFADDR не используемый в сети. Это позволит иметь возможность проверять свободность эфира в любой момент без специального включения приемника (с действительным адресом приемника, что могло привести к приему нового пакета при еще необработанном старом пакете). Убраны лишние конфигурации, найдена ошибка в объявлении USE_HY_STM32MINI.
6. Различия в реализации приемников UART и nRF приводят к огромным различиям обработки информации от них. 
Сделана попытка отказаться от отключения nRF с заменой адреса на RF_ADDR_SILENCE. Оказалось, что передача ACK осуществляется уже после срабатывания прерывания по HAL_NRF_RX_DR. Приемное устройство успевает изменить свой адрес, соответственно ACK передается уже на адрес RF_ADDR_SILENCE. И передатчик его не получает, продолжая слать данные на адрес UpRFAddr до последнего, получая в результате ошибку. В этом случае помогает введение принудительной паузы перед изменением адреса приемника. В результате получается громоздкое неочевидное решение, требующее дополнительных временных затрат и снижения надежности. Так же был испробован метод изменения HAL_NRF_PIPE0 передатчика на RF_ADDR_SILENCE, что должно бы дать возможность принимать ACK от приемника с уже измененным адресом, но метод по непонятным причинам не работает (работает, но необходимо менять адрес приемного устройства максимально быстро). К тому же появляется потенциальная возможность принимать ACK от любого другого устройства сети. Вопрос запрета приема остается открытым. 
Большая часть ошибок с потерей пакетов происходит из-за поспешной попытки передать информацию (при ретрансляции или при выдаче запрошенных данных). Даже если в приемное устройство введена задержка ~300 мкс для передачи ACK с корректным адресом, этот ACK может не дойти до передающего устройства с первого раза. Приемное устройство после небольшой задержки начинает передачу, но передающее (которое теперь по сценарию должно принимать), так и не получив ACK, делает еще несколько попыток передать. Останавливается раньше приемного и имеет шанс получить от него ответные данные. Возникает иллюзия потерянного пакета. При ретрансляции пакета далее по цепочке аналогично возникает иллюзия потерянного пакета. Кроме этого при передаче запрошенных данных может реально потеряться пакет от приемного устройства. 
Идеальным решением был бы контроль эфира перед началом трансляции. Но вызов функции hal_nrf_get_carrier_detect() в момент передачи ACK (и вообще при работе на передачу nRF) может вызвать серьезныю ошибку. Кроме этого оказалось, что чувствительность такого способа очень мала и сводит ценность этой функции к нулю.
В результате принято решение использовать большую задержку (RF_RETRANSMITS * RF_RETRANS_DELAY либо 3 * RF_RETRANS_DELAY, что достаточно в большинстве случаев). Не обращать внимание на прерывание HAL_NRF_MAX_RT (которых должно стать очень мало и только в случае реальной потери) и требовать подтверждающего пакета на все не широковещательные пакеты. Ошибку фиксировать при отсутствии этого подтверждающего пакета.
Как показывают реальные испытания, ошибка фиксируется как при потере информационного пакета, так и при потере подтверждающего пакета. Что так же приводит к появлениюю иллюзии потерянного пакета.
7. Сильно переработан стек сети. Каждое приемопередающие устройство приведено к общему виду и представляет теперь унифицированный трансивер. Каждый трансивер имеет единообразные методы передачи и приема информации и статусную переменную типа LAN_TransceiverStatus. Реализация методов зависит от физической реализации трансивера. Например адрес назначения не имеет значения для UART.
В связи с унификацией пропала возможность просто передавать данные в UART. К UART имеет доступ только модуль UARTTransceiver. 
Стек сети имеет два основных метода: 
а) u8 LAN_PushPacketToFIFO(u8 *Packet) - добавление в FIFO пакета Packet при наличии свободного места. Этот метод не имеет мьютексов, поэтому при вызове этой функции не из прерывания может возникнуть ошибка, т.к. прерывания от трансиверов активно используют эту функцию.
б) void LAN_PushStack(void) - обрабатывает один пакет из FIFO. Данная функция должна периодически вызываться для продвижения пакетов в FIFO. Пакет из FIFO удаляется только если он полностью обработан (если, например, требуется передача пакета в трансивер, который сейчас занят, то пакет из FIFO не удаляется и будет обработан при следующем вызове метода).
Добавлена новая функция void LAN_ReportError(TLAN_Errors Error, u8 *Note). Она может генерировать пакеты, адресуемые ВНИЗ, для информирования хоста о возникших ошибках. Кроме этого для удобства отладки идет подсчет ошибок счетчиком и вывод типа последней ошибки в отдельную переменную. Реакция на ошибку индивидуальна для каждого типа ошибки и может не отправляться хосту. 
Унификация трансиверов и наличие нескольких трансиверов в одном устройстве подразумевает наличие нескольких сетевых адресов у устройства. На данный момент это противоречит идеологии сети. Каждое устройство имеет один сетевой адрес. Однако если пакет, адресованный устройству может приходить только через один трансивер, то оно его обработает без ошибок. Уже сейчас в сетевом адресе первый байт отвечает не столько за адресацию устройству, сколько за выбор трансивера, через который осуществляется связь с этим устройством. Этот байт (префикс) одинаков для всех однотипных трансиверов. 
Но далее, для гладкого вписывания стека сети в устройство с несколькими трансиверами, необходимо кардинальное изменение библиотеки, с отделением того байта от сетевого адреса и превращение его в индикатор нужного трансивера. Т.о. устройство сможет иметь до 256 трансиверов, а адрес устройства в сети будет иметь только 2 байта. Адрес в трансивере целесообразно сделать отличным от сетевого - своего рода MAC-адрес, который будет производным от сетевого адреса.
Кроме этого в сетевую библиотеку добавлены функции для работы со статусом трансивера.
Изменен механизм формирования временных задержек. Появилась возмоность запустить нужную функцию через определенное время. Таких задержек может отсчитываться несколько одновременно. Данный механизм активно используется для блокировки использования NRF24, который нельзя использовать в течении некоторого времени после приема пакета из радиоэфира. Это необходимо, чтобы дать возможность трансиверу выдать ACK. Использование фиксированной задержки признано оптимальным вариантом борьбы с потерянными ACK.
8. Изменена структура и трактование передаваемых пакетов. Теперь устройство имеет двухбайтовый сетевой адрес. MAC-адреса на трансиверах в общем случае не имеют отношения к сетевым адресам. Многие функции и названия приведены к единому стандарту. 
Найден источник проблем, связанных с адресами nRF24. Последние байты адреса должны быть уникальными для всех ШЕСТИ приемных точек устройства. Последний байт адреса соответствует первому байту в программе, эти байты часто оказывались одинаковыми для PIPE0 и PIPE1, что приводило к отказу трансивера принимать пакеты из эфира. В связи с этим дополнительный байт, приписываемый к сетевому адресу устройства для получения MAC-адреса nRF24 установлен в конец.
Убраны все функции, связанные с редактированием статуса трансивера. Тип стасуса изменен на структуру, что позволило в удобном виде редактировать статус на месте в самом драйвере трансивера.
Изменен парсинг пакета SetBridge. Теперь устройство ищет свой двухбайтовый адрес в пакете и устанавливает исходящий канал в соответствии со значением справа от своего адреса (где теперь обязательно должно стоять "LAD" вместо 000), либо "LAD", если справа ничего нет (последняя позиция). Нисходящий канал всегда устанавливается в соответствии со значением слева от своего адреса.
